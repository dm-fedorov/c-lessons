# Язык программирования C

<blockquote>И хотя С используется все реже и реже, он остается лингва-франка для работающих программистов. Это тот язык, который используется чтобы общаться друг с другом и, что еще более важно, он гораздо ближе к машине, чем “современные” языки, которым вас учат в колледже: ML, Java, Python, какому бы новомодному мусору не учили сегодня. Вам нужно, как минимум, семестр чтобы стать ближе к машине, иначе вы никогда не сможете создавать эффективный код на языках более высокого уровня. Вы никогда не сможете работать над компиляторами и операционными системами, а это одни из самых лучших рабочих мест. Вам никогда не доверят создавать архитектуру больших проектов. Меня не интересует сколько вы знаете о последовательностях, замыканиях и обработке исключений, если вы не можете объяснить почему while (*s++ = *t++); копирует строку, или это для вас не одна из самых естественных вещей в мире, ну, тогда вы программируете основываясь на суевериях, подобно доктору, который не зная анатомии отпускает рецепт основываясь на том, что говорит аптекарша. (Джоэл Спольски, программист, писатель) </blockquote>

####Примерный перечень вопросов для подготовки к экзамену по дисциплинам Языки программирования и Языки и методы программирования (2 семестр).

- Работа с примитивными типами данных (int, char, float, double, long, unsiged ...), автоматические преобразования данных. Тип и структура данных с плавающей точкой (float, double), машинная точность, ошибки округления и контроль точности вычислений.
- Функции и передача параметров, локальные переменные. Понятие о стеке вызовов функций. Рекурсивные функции, проблема переполнения стека.
- Типы распределения памяти  (program, heap, stack, static)
- Управляющие структуры - операторы ветвления, циклы. Варианты циклов for и while. Инициализация переменных в циклах. Ключевые слова break, continue
- Локализация переменных, области видимости. Статические переменные в функциях.
- Указатели, арифметика указателей, адреса переменных.
- Массивы и связь с указателями. Передача параметров по указателю
- Указатели на указатели. Многомерные массивы.
- Работа со строками. Строки как массивы символов. Строки и указатели. Основные библиотечные функции для работы со строками. Проблемы переполнения буфера.
- Структуры и объединения, typedef, sizeof, доступ к полям, использование в программах для создания сложных типов данных. Массивы структур
- Динамическое распределение памяти - malloc, calloc, realloc, free. Приведение (кастинг) данных к определенному типу. Корректная работа с памятью (sizeof, приведение к типу, etc). Типичные ошибки (переполнение буфера, утечки памяти, попытки доступа к освобожденной памяти, попытки дважды освобождать память, возврат указателя на локальную переменную, etc).
- Основные динамические структуры данных - связные списки, стеки, очереди, деревья. 
- Основные алгоритмы - сортировка, поиск, etc. 
- Функции с неопределенным / переменным числом аргументов. Varargs.
- Работа с аргументами командной строки в программах
- Ввод / вывод. Чтение из файлов / запись в файлы. Буферное чтение / запись.
- Препроцессор, макро-директивы
- Проекты с несколькими файлами, заголовочные файлы (.h), использование препроцессора (#define, #include, #if, etc), отделение интерфейса от имплементации, области видимости static, extern
- Этапы компиляции. Раздельная компиляция, объектные файлы, линковка. Make - файлы. Работа с компилятором и linker из командной строки. Основные флаги компилятора.

<blockquote>Мне нравится разбираться в том, как все работает. Хороший способ  проверки – реализовывать все самому. Для меня программирование - это не ввод кода в машину, это процесс понимания. Программирование есть понимание. Я люблю понимать, как все устроено. Зачем я создаю интерфейс для X Windows? Чтобы разобраться, как работает Х-протокол. Реализация чего-нибудь – сильный мотивирующий фактор. Рекомендую всем. Хотите понять Си – напишите для него компилятор. Хотите понять Лисп – напишите для него компилятор или интерпретатор. Некоторые говорят: «Компилятор – это же так трудно». Совсем нет. Это легко. Есть масса мелочей, которые не трудны и которые нужно освоить. Надо разбираться в структурах данных. Надо разбираться в хеш-таблицах и в парсинге. В генерировании кода. В техниках интерпретации. Каждый из этих предметов не особенно сложен. Начинающие думают, что это все большие и сложные темы, и поэтому к ним не подступают. Все, что вы не делаете, трудно, все, что вы уже сделали, легко (Джо Армстронг, один из основателей языка
программирования Erlang) </blockquote>

####Лабораторные работы по дисциплине "Языки программирования" (направление "Информационная безопасность"):

Во всех программах обеспечить защиту от произвольного ввода (например, вводим с клавиатуры только то, что нужно по условию задачи и в заданном интервале). 

#####Лабораторная работа №1 (кодовое имя «Тейлор»)

Написать программу, подсчитывающую значение экспоненты через разложение в ряд Тейлора. C клавиатуры задать x и точность вычисления, сравнить полученный результат со встроенной функцией exp(x). 

#####Лабораторная работа №2 (кодовое имя «Парольная система»)

Реализовать систему, проверяющую логин и пароль пользователя. Запрос логина и пароля происходит с клавиатуры, затем проверяется введенный пароль (пароль может состоять из _произвольной_ строкой символов) для указанного пользователя, в системе может быть _несколько_ пользователей. Если пароль правильный, то можем войти в систему и сменить свой пароль (длина нового пароля не превышает длину старого). Метод хранение пароля: в зашифрованном виде в файле, например, шифрование XOR. Если три раза пароль введен неправильно, то выходим из программы. Обеспечить безопасную работу программы. Разбить исходный текст программы на несколько файлов (использовать заголовочный файл), для сборки файлов использовать утилиту make. 

#####Лабораторная работа №3 (кодовое имя «Сортировка»)

- Создать массив случайных чисел (100-200-500-1000 элементов).
- Отсортировать массив выбором и вставкой (метод сортировки задается аргументом командной строки).
- Сгенерировать много раз случайное число и с помощью бинарного поиска найти его в отсортированном массиве.
- Оценить время работы программы для разных видов сортировки и массивов разных размеров (построить графики).

#####Лабораторная работа №4 (кодовое имя «Работа с динамическими структурами данных»)
Выводим на экран меню с возможностью выполнить перечисленные действия:
- Создать первый элемент односвязного списка.
- Добавить элемент в конец односвязного списка.
- Удалить элемент с конца односвязного списка.
- Просмотреть содержимое односвязного списка.
- Удалить весь односвязный список. 
- Выполнить последовательный поиск заданного элемента в односвязном списке.
- Выйти из программы.

Разбить исходный текст программы на несколько файлов (использовать заголовочный файл), для сборки файлов использовать утилиту make. 

Выполните проверку с помощью утилиты valgrind: <http://cppstudio.com/post/4348/>

#####Лабораторная работа №5 (кодовое имя "Дерево поиска-1")

Отсортируйте последовательность чисел из файла путём вставки в двоичное дерево поиска (дерево изначально пусто). Длина последовательности заранее неизвестна.

Пример описания дерева:

```
struct item {
	int data;
	struct item *left, *right;
};
struct item *root = NULL;
```
Разбить исходный текст программы на несколько файлов (использовать заголовочный файл), для сборки файлов использовать утилиту make. 

Выполните проверку с помощью утилиты valgrind: <http://cppstudio.com/post/4348/>

Или на 'автомат':

#####Лабораторная работа №4 (кодовое имя "Хаффман")

Реализуйте архиватор и деархиватор, работающий по методу Хаффмана. 
Интерфейс работы программы (пример):

```
$ ./huffman archive.huf file.txt
$ ./huffman -d archive.huf unpacked.txt
```

Для проверки корректности архивации и деархивации попробуйте запаковать и распаковать двоичный файл (например, /bin/bash) и при помощи программы diff проверить работу программы.

Разбить исходный текст программы на несколько файлов (использовать заголовочный файл), для сборки файлов использовать утилиту make. 

Выполните проверку с помощью утилиты valgrind: <http://cppstudio.com/post/4348/>

#####Лабораторная работа №5 (кодовое имя "Дерево поиска-2")

Подсчитайте количество вхождений слов в тексте (из файла), используя для хранения слов двоичное дерево поиска.

Пример описания дерева для этой задачи:

```
struct node{
	char *word;
	int count;
	struct item *left, *right;
}; 
struct node *root = NULL;
```
Разбить исходный текст программы на несколько файлов (использовать заголовочный файл), для сборки файлов использовать утилиту make. 

Выполните проверку с помощью утилиты valgrind: <http://cppstudio.com/post/4348/>
